{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Loli documentation Loli is a embedded programming language. Loli is statically-typed, Loli uses reference counting for memory management with garbage collection as a fallback. Key features of Loli : - Built-in template mode - Embed/extend in C - Single-inheritance classes - Exceptions - Generics - Algebraic data types Syntax overview Declarations Variables must be declared before they are used, with the var keyword: var x = 5 var y: Double = 5.32 var z = [1, 2, 3], hi = \"Hello, world!\" The value used to initialize a variable determines the type of the variable. In most cases, var does not need extra type information. However, sometimes the right side of an initialization doesn't provide enough info and type information must be provided: var some_list: List[Double] = [] Literals Loli has several predefined classes, and syntax for using them as well. Boolean Either true or false . Byte A numeric value from 0 to 255. Can be declared like an Integer but with a suffix of t , or like a String using a single character or escape sequence between single quote marks: 0t 0xFFt 255t 'a' '\\t' ByteString An array of Byte values. A String , but with no guarantees about embedded \\0 values or utf-8. Allows any escape character between quotes: b\"123456\" b\"\\0\\1\\2\" b\"\\255\\254\\t\" b\"\"\"A \\ multi-line \\ ByteString\"\"\" Double 0.00000005 -1.7 10e1 5e-5 Hash A Hash is a key to value mapping. Only Integer and String can be used for the key. The value can be anything, so long as there is a consistent type. If a Hash literal contains the same key twice, both values will still be computed if necessary, but the right-most key wins: var a_hash = [\"a\" => 1, \"b\" => 2, \"c\" => 3] var empty_hash: Hash[String, Integer] = [] Integer A 64-bit signed value that can be represented using different bases: 12345 -67890 0c744 x0xFF 0b101010101 List A List is composed of values put together in brackets. The values must have some common type: var a_list = [1, 2, 3] var a_range = range(1, 3) var empty_list: List[Double] = [] String Represents a block of text. String carries the guarantee that all instances are valid utf-8, and that they do not carry \\0 characters inside. String literals are single-line by default, but can be multi-line as well: var hi = \"Hello, world!\" var multi_line = \"\"\"Hello, \\ world!\"\"\" Tuple A Tuple is similar to a List , except that Tuple s have a fixed size, but can hold types that don't have any similarity to each other. A Tuple begins with <[ and ends with ]> : var a_tuple: Tuple[String, Double] = <[\"hi\", 34.93]> Comments There are two kinds of comments: # A single-line comment #[ And a multi-line comment ]# Escape codes String , ByteString , and Byte support the following escape sequences: - \\a : Bell - \\b : Backspace - \\t : Tab - \\n : A newline - \\r : Carriage return - \\\" : The \" character - \\' : The ' character - \\\\ : The \\ character - \\/ : \\ on Windows, / elsewhere. - \\ddd : 'ddd' is up to 3 digits, scanned in decimal. This can yield any value between 0 and 255 inclusive. Scanning stops either after 3 digits have been consumed, or a non-base 10 digit occurs. - \\<newline> : ByteString and String only. The newline of the current line and the leading whitespace ( ' ' or '\\t' ) will be omitted from the literal. Operators Basic arithmatic operations ( + - * / ) can be used for two Double values, or two Integer values, or when there is one Double and one Integer value. The result is a Double if either side is a Double , Integer otherwise. Other primitive operations (shifts, bitwise operations, and modulo) are only valid if both sides are Integer . Comparison Comparison operations ( >= > < <= ) are allowed on any two sets of Integer , String , or Double . Equality operations ( == != ) are allowed on any two equivalent types. Simple values like Integer , and Double are straightforward: They are equal only when they are the same value. List , Tuple , Hash , and variants use structural comparison. All other containers and more interesting types use identity comparison. A comparison such as SomeClass(2, 4) == SomeClass(2, 4) will always return false , since each SomeClass is a different instance. Interpolation The ++ operator and String.format all make use of built-in interpolation. Interpolation works as follows: Primitive values such as Integer , Double , and String have their content written out. Built-in containers have their inner contents written out. Hash does not guarantee an ordering to the contents it writes out. Non-scoped variants print just their name and their contents. Scoped variants print out the enum name and a dot first. Classes print out their address. Condition if x == 0: { # do something... elif x == 1: { # do something another... else: # do something another... } Loops There are while , for and built-in classes' iterators(such as List.each ): var i = 0 while i < 3: { sayln(i) i += 1 } for n in 0...3: { sayln(n) } range(1, 3).each(|x: Integer| sayln(x)) Functions In Loli functions are first-class entities. They can be passed around as arguments, returned, stored in vars, and so on. Declaration fn add(a: Integer, b: Integer): Integer { return a + b } The above defines add as taking two Integer values and producing an Integer as output. In the event that a function has no arguments, or produces no output, that entire section can be omitted: fn life_meaning: Integer { return 42 } fn nothing(a: Integer) { } fn empty { } Like many curly-brace family languages, functions are invoked by passing their arguments like so: add(5, 10) to receive 15 . Omitting a return type doesn't mean that a function doesn't return anything. A function that doesn't mention a return value will actually the value unit of the class Unit . Since all functions actually return a value (even if it's just unit ), it's possible to chain functions that otherwise could not be chained: fn nop { } sayln(nop()) # unit Functions can also be used as arguments: fn square(a: Integer): Integer { return a * a } fn apply(a: Integer, fn: Function(Integer => Integer)): Integer { return fn(a) } sayln(apply(10, square)) # 100 The fn keyword has a number of modifiers that are available to it ( pub , future , sta , etc.). For simplicity, required that modifiers are introduced in alphabetical order. Lambdas One problem with the above example is that square is relatively simple. One is likely to assume that square will take an a , multiply it by itself, and return it. But suppose that the codebase is large, and square is somewhere else. If there is an issue, the source to square must be tracked down. An alternative is to use a lambda. Lambdas are nameless functions that can be used where a function is needed. A lambda begins with (| , followed by argument names, until | is seen. From there, everything until there is a matching ) for the (| is the body of the lambda. Here's the above example, rewritten to use a lambda: fn apply(a: Integer, fn: Function(Integer => Integer)): Integer { return fn(a) } sayln(apply(10, (|a| a * a))) # 100 Another feature of lambdas is that they are values, and the var they're assigned to can opt to have a different lambda. On the other hand, lambdas are quite restricted, and not eligible for many of the function features listed below. Lambdas don't require type information. In the above example, the lambda uses inference to determine that a should be of type Integer . Since lambdas exist primarily to return some kind of a value, the return type of a lambda is the last expression that run. If the last expression is part of a block such as if or match , then the return type is instead unit . Using the future keyword before fn denotes that the function will be declared at some point in the future. Instead of giving the fn a body, it must instead have the triple dot ( ... ) token: future fn add(Integer, Integer): Integer { ... } # *a lot of code* fn add(x: Integer, y: Integer): Integer { return x + y } Functions declared with future are not allowed to specify names for their variables, and are not allowed to use keyword arguments. While there are unresolved future declarations, it is a syntax error to attempt to import a file, declare a class property, or declare a variable. This is done to prevent the resolving function from using variables that are not properly initialized. Additionally, if a class or module finishes with incomplete future declarations, a syntax error is generated immediately. Varargs Adding ... to the end of a type denotes that the function can receive a variable number of arguments of that type. The function receives the arguments as a List of the type provided. If no arguments were passed, the List will be empty. fn sum(n: Integer...): Integer { var result = 0 n.each(|x| result += x) return result } Optargs Adding * before a type, then = <value> after it denotes that the parameter is optional. Optional arguments may be a simple value, or an expression. Required arguments must not come after an optional argument. The expressions of optional arguments, if run, are always run from left to right. As a result, it's permissible for a parameter to depend on another to the left of it. fn sample(a: *Integer = 10): Integer { return a + 10 } The calling function runs the optional argument expressions each time they are needed. As a result, each invocation will receive fresh versions of a default argument that do not carry over into the next invocation. Mixing variable and optional arguments is permissible. By default, the vararg parameter receives an empty List if no values are passed. Mixing these two features allows a different default value. Keyargs Placing :<name> before the name of a parameter will allow the function to be called using keyword arguments. Keyword arguments allow calling a function with arguments in a different order than the function's parameters. The function can then be called either with positional arguments or keyword arguments. fn sample(:first x: Integer, :second y: Integer, :third z: Integer): Integer { return x + y + z } sample(1, 2, 3) # 6 sample(1, :second 2, :third 3) # 6 sample(:third 30, :first 10, :second 5) # 45 Classes User-declared classes provide a way to group together a set of data and related functions. In Loli , classes are only allowed to have one parent class at most as a way of keeping their internal implementation simpler. Declaration class Point(x: Integer, y: Integer) { pub var @x = x pub var @y = y } The body of the class block serves to both define class variables and to initialize them. Inside a class, properties have a @ prefix. Outside of it, both methods and properties are accessed using a dot. class Point(x: Integer, y: Integer) { pub var @x = x pub var @y = y pub fn inc(x_value: Integer, y_value: Integer) { @x += x_value @y += y_value } } Because both class properties and class methods are accessed the same outside of a class, it is a syntax error to have a property and a method with the same name. In situations where class inputs become properties, a shorthand is available: class Point(pub var @x: Integer, pub var @y: Integer) { } Scope Prior to declaring a class member, a scope is needed. There are three possible scopes that a class member or function can have: - pub denotes that the member is available anywhere. - pro restricts the member to the class itself, or any class that inherits from it. - pri restricts the member to only the class. Inheritance Classes use the < token to denote inheriting from another class when writing the header: class Point2D(pub var @x: Integer, pub var @y: Integer) {} class Point3D(x: Integer, y: Integer, pub var @z: Integer) < Point2D(x, y) {} Static methods By default, class methods receive an implicit self parameter as their first argument. The sta qualifier, when applied to a class method, turns that behavior off: Exceptions Occasionally there are errors that are not expected: A subscript of a List is out-of-bounds or there is an accidental attempt to divide by zero. There are predefined exceptions for that. The base of all exceptions is the Exception class. It is declared as follows: class Exception(pub var @message: String) { pub var @traceback: List[String] = [] } When an exception is raised the traceback field of it is replaced with the current call stack. List of predefined exceptions: - Exception : Base class of all raiseable exceptions. - DivisionByZero : Attempt to divide or modulo by zero. - IndexError : Out-of-bounds access of a container (such as List ), String or ByteString . - IOError : Incorrect usage of a File . - KeyError : Attempt to read a value from a Hash that does not exist. - RuntimeError : Bad runtime action such as modifying a hash during iteration or exceeding the recursion limit. - ValueError : Invalid or unreasonable value provided. Any of these exceptions can be inherited to create a custom exception. Exception can be raised using raise keyword: raise IndexError(\"Index out of range\") And catched using try/except block: try: { raise IndexError(\"Index out of range\") except Exception as e: sayln(\"Exception: {0}\".format(e.message)) } Generics In Loli classes, enums, and functions can make use of generics. They must be a single capital letter, must be declared before use, and yet there are no traits or qualifiers. class Stack[A](element: A) { pub var @contents = [element] pub fn push(value: A): self { @contents.push(value) } } Stack(1).push(2).push(3) # [1, 2, 3]","title":"Welcome to Loli documentation"},{"location":"#welcome-to-loli-documentation","text":"Loli is a embedded programming language. Loli is statically-typed, Loli uses reference counting for memory management with garbage collection as a fallback. Key features of Loli : - Built-in template mode - Embed/extend in C - Single-inheritance classes - Exceptions - Generics - Algebraic data types","title":"Welcome to Loli documentation"},{"location":"#syntax-overview","text":"","title":"Syntax overview"},{"location":"#declarations","text":"Variables must be declared before they are used, with the var keyword: var x = 5 var y: Double = 5.32 var z = [1, 2, 3], hi = \"Hello, world!\" The value used to initialize a variable determines the type of the variable. In most cases, var does not need extra type information. However, sometimes the right side of an initialization doesn't provide enough info and type information must be provided: var some_list: List[Double] = []","title":"Declarations"},{"location":"#literals","text":"Loli has several predefined classes, and syntax for using them as well.","title":"Literals"},{"location":"#boolean","text":"Either true or false .","title":"Boolean"},{"location":"#byte","text":"A numeric value from 0 to 255. Can be declared like an Integer but with a suffix of t , or like a String using a single character or escape sequence between single quote marks: 0t 0xFFt 255t 'a' '\\t'","title":"Byte"},{"location":"#bytestring","text":"An array of Byte values. A String , but with no guarantees about embedded \\0 values or utf-8. Allows any escape character between quotes: b\"123456\" b\"\\0\\1\\2\" b\"\\255\\254\\t\" b\"\"\"A \\ multi-line \\ ByteString\"\"\"","title":"ByteString"},{"location":"#double","text":"0.00000005 -1.7 10e1 5e-5","title":"Double"},{"location":"#hash","text":"A Hash is a key to value mapping. Only Integer and String can be used for the key. The value can be anything, so long as there is a consistent type. If a Hash literal contains the same key twice, both values will still be computed if necessary, but the right-most key wins: var a_hash = [\"a\" => 1, \"b\" => 2, \"c\" => 3] var empty_hash: Hash[String, Integer] = []","title":"Hash"},{"location":"#integer","text":"A 64-bit signed value that can be represented using different bases: 12345 -67890 0c744 x0xFF 0b101010101","title":"Integer"},{"location":"#list","text":"A List is composed of values put together in brackets. The values must have some common type: var a_list = [1, 2, 3] var a_range = range(1, 3) var empty_list: List[Double] = []","title":"List"},{"location":"#string","text":"Represents a block of text. String carries the guarantee that all instances are valid utf-8, and that they do not carry \\0 characters inside. String literals are single-line by default, but can be multi-line as well: var hi = \"Hello, world!\" var multi_line = \"\"\"Hello, \\ world!\"\"\"","title":"String"},{"location":"#tuple","text":"A Tuple is similar to a List , except that Tuple s have a fixed size, but can hold types that don't have any similarity to each other. A Tuple begins with <[ and ends with ]> : var a_tuple: Tuple[String, Double] = <[\"hi\", 34.93]>","title":"Tuple"},{"location":"#comments","text":"There are two kinds of comments: # A single-line comment #[ And a multi-line comment ]#","title":"Comments"},{"location":"#escape-codes","text":"String , ByteString , and Byte support the following escape sequences: - \\a : Bell - \\b : Backspace - \\t : Tab - \\n : A newline - \\r : Carriage return - \\\" : The \" character - \\' : The ' character - \\\\ : The \\ character - \\/ : \\ on Windows, / elsewhere. - \\ddd : 'ddd' is up to 3 digits, scanned in decimal. This can yield any value between 0 and 255 inclusive. Scanning stops either after 3 digits have been consumed, or a non-base 10 digit occurs. - \\<newline> : ByteString and String only. The newline of the current line and the leading whitespace ( ' ' or '\\t' ) will be omitted from the literal.","title":"Escape codes"},{"location":"#operators","text":"Basic arithmatic operations ( + - * / ) can be used for two Double values, or two Integer values, or when there is one Double and one Integer value. The result is a Double if either side is a Double , Integer otherwise. Other primitive operations (shifts, bitwise operations, and modulo) are only valid if both sides are Integer .","title":"Operators"},{"location":"#comparison","text":"Comparison operations ( >= > < <= ) are allowed on any two sets of Integer , String , or Double . Equality operations ( == != ) are allowed on any two equivalent types. Simple values like Integer , and Double are straightforward: They are equal only when they are the same value. List , Tuple , Hash , and variants use structural comparison. All other containers and more interesting types use identity comparison. A comparison such as SomeClass(2, 4) == SomeClass(2, 4) will always return false , since each SomeClass is a different instance.","title":"Comparison"},{"location":"#interpolation","text":"The ++ operator and String.format all make use of built-in interpolation. Interpolation works as follows: Primitive values such as Integer , Double , and String have their content written out. Built-in containers have their inner contents written out. Hash does not guarantee an ordering to the contents it writes out. Non-scoped variants print just their name and their contents. Scoped variants print out the enum name and a dot first. Classes print out their address.","title":"Interpolation"},{"location":"#condition","text":"if x == 0: { # do something... elif x == 1: { # do something another... else: # do something another... }","title":"Condition"},{"location":"#loops","text":"There are while , for and built-in classes' iterators(such as List.each ): var i = 0 while i < 3: { sayln(i) i += 1 } for n in 0...3: { sayln(n) } range(1, 3).each(|x: Integer| sayln(x))","title":"Loops"},{"location":"#functions","text":"In Loli functions are first-class entities. They can be passed around as arguments, returned, stored in vars, and so on.","title":"Functions"},{"location":"#declaration","text":"fn add(a: Integer, b: Integer): Integer { return a + b } The above defines add as taking two Integer values and producing an Integer as output. In the event that a function has no arguments, or produces no output, that entire section can be omitted: fn life_meaning: Integer { return 42 } fn nothing(a: Integer) { } fn empty { } Like many curly-brace family languages, functions are invoked by passing their arguments like so: add(5, 10) to receive 15 . Omitting a return type doesn't mean that a function doesn't return anything. A function that doesn't mention a return value will actually the value unit of the class Unit . Since all functions actually return a value (even if it's just unit ), it's possible to chain functions that otherwise could not be chained: fn nop { } sayln(nop()) # unit Functions can also be used as arguments: fn square(a: Integer): Integer { return a * a } fn apply(a: Integer, fn: Function(Integer => Integer)): Integer { return fn(a) } sayln(apply(10, square)) # 100 The fn keyword has a number of modifiers that are available to it ( pub , future , sta , etc.). For simplicity, required that modifiers are introduced in alphabetical order.","title":"Declaration"},{"location":"#lambdas","text":"One problem with the above example is that square is relatively simple. One is likely to assume that square will take an a , multiply it by itself, and return it. But suppose that the codebase is large, and square is somewhere else. If there is an issue, the source to square must be tracked down. An alternative is to use a lambda. Lambdas are nameless functions that can be used where a function is needed. A lambda begins with (| , followed by argument names, until | is seen. From there, everything until there is a matching ) for the (| is the body of the lambda. Here's the above example, rewritten to use a lambda: fn apply(a: Integer, fn: Function(Integer => Integer)): Integer { return fn(a) } sayln(apply(10, (|a| a * a))) # 100 Another feature of lambdas is that they are values, and the var they're assigned to can opt to have a different lambda. On the other hand, lambdas are quite restricted, and not eligible for many of the function features listed below. Lambdas don't require type information. In the above example, the lambda uses inference to determine that a should be of type Integer . Since lambdas exist primarily to return some kind of a value, the return type of a lambda is the last expression that run. If the last expression is part of a block such as if or match , then the return type is instead unit . Using the future keyword before fn denotes that the function will be declared at some point in the future. Instead of giving the fn a body, it must instead have the triple dot ( ... ) token: future fn add(Integer, Integer): Integer { ... } # *a lot of code* fn add(x: Integer, y: Integer): Integer { return x + y } Functions declared with future are not allowed to specify names for their variables, and are not allowed to use keyword arguments. While there are unresolved future declarations, it is a syntax error to attempt to import a file, declare a class property, or declare a variable. This is done to prevent the resolving function from using variables that are not properly initialized. Additionally, if a class or module finishes with incomplete future declarations, a syntax error is generated immediately.","title":"Lambdas"},{"location":"#varargs","text":"Adding ... to the end of a type denotes that the function can receive a variable number of arguments of that type. The function receives the arguments as a List of the type provided. If no arguments were passed, the List will be empty. fn sum(n: Integer...): Integer { var result = 0 n.each(|x| result += x) return result }","title":"Varargs"},{"location":"#optargs","text":"Adding * before a type, then = <value> after it denotes that the parameter is optional. Optional arguments may be a simple value, or an expression. Required arguments must not come after an optional argument. The expressions of optional arguments, if run, are always run from left to right. As a result, it's permissible for a parameter to depend on another to the left of it. fn sample(a: *Integer = 10): Integer { return a + 10 } The calling function runs the optional argument expressions each time they are needed. As a result, each invocation will receive fresh versions of a default argument that do not carry over into the next invocation. Mixing variable and optional arguments is permissible. By default, the vararg parameter receives an empty List if no values are passed. Mixing these two features allows a different default value.","title":"Optargs"},{"location":"#keyargs","text":"Placing :<name> before the name of a parameter will allow the function to be called using keyword arguments. Keyword arguments allow calling a function with arguments in a different order than the function's parameters. The function can then be called either with positional arguments or keyword arguments. fn sample(:first x: Integer, :second y: Integer, :third z: Integer): Integer { return x + y + z } sample(1, 2, 3) # 6 sample(1, :second 2, :third 3) # 6 sample(:third 30, :first 10, :second 5) # 45","title":"Keyargs"},{"location":"#classes","text":"User-declared classes provide a way to group together a set of data and related functions. In Loli , classes are only allowed to have one parent class at most as a way of keeping their internal implementation simpler.","title":"Classes"},{"location":"#declaration_1","text":"class Point(x: Integer, y: Integer) { pub var @x = x pub var @y = y } The body of the class block serves to both define class variables and to initialize them. Inside a class, properties have a @ prefix. Outside of it, both methods and properties are accessed using a dot. class Point(x: Integer, y: Integer) { pub var @x = x pub var @y = y pub fn inc(x_value: Integer, y_value: Integer) { @x += x_value @y += y_value } } Because both class properties and class methods are accessed the same outside of a class, it is a syntax error to have a property and a method with the same name. In situations where class inputs become properties, a shorthand is available: class Point(pub var @x: Integer, pub var @y: Integer) { }","title":"Declaration"},{"location":"#scope","text":"Prior to declaring a class member, a scope is needed. There are three possible scopes that a class member or function can have: - pub denotes that the member is available anywhere. - pro restricts the member to the class itself, or any class that inherits from it. - pri restricts the member to only the class.","title":"Scope"},{"location":"#inheritance","text":"Classes use the < token to denote inheriting from another class when writing the header: class Point2D(pub var @x: Integer, pub var @y: Integer) {} class Point3D(x: Integer, y: Integer, pub var @z: Integer) < Point2D(x, y) {}","title":"Inheritance"},{"location":"#static-methods","text":"By default, class methods receive an implicit self parameter as their first argument. The sta qualifier, when applied to a class method, turns that behavior off:","title":"Static methods"},{"location":"#exceptions","text":"Occasionally there are errors that are not expected: A subscript of a List is out-of-bounds or there is an accidental attempt to divide by zero. There are predefined exceptions for that. The base of all exceptions is the Exception class. It is declared as follows: class Exception(pub var @message: String) { pub var @traceback: List[String] = [] } When an exception is raised the traceback field of it is replaced with the current call stack. List of predefined exceptions: - Exception : Base class of all raiseable exceptions. - DivisionByZero : Attempt to divide or modulo by zero. - IndexError : Out-of-bounds access of a container (such as List ), String or ByteString . - IOError : Incorrect usage of a File . - KeyError : Attempt to read a value from a Hash that does not exist. - RuntimeError : Bad runtime action such as modifying a hash during iteration or exceeding the recursion limit. - ValueError : Invalid or unreasonable value provided. Any of these exceptions can be inherited to create a custom exception. Exception can be raised using raise keyword: raise IndexError(\"Index out of range\") And catched using try/except block: try: { raise IndexError(\"Index out of range\") except Exception as e: sayln(\"Exception: {0}\".format(e.message)) }","title":"Exceptions"},{"location":"#generics","text":"In Loli classes, enums, and functions can make use of generics. They must be a single capital letter, must be declared before use, and yet there are no traits or qualifiers. class Stack[A](element: A) { pub var @contents = [element] pub fn push(value: A): self { @contents.push(value) } } Stack(1).push(2).push(3) # [1, 2, 3]","title":"Generics"}]}